# Autogenerated input type of AddChannelMembers
input AddChannelMembersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput]!
}

# Autogenerated return type of AddChannelMembers
type AddChannelMembersPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddCollaborator
input AddCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user_ids: [ID]!
}

# Autogenerated return type of AddCollaborator
type AddCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of AddGroupUsers
input AddGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

# Autogenerated return type of AddGroupUsers
type AddGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# An attachment block
type Attachment implements Block, Model {
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  file_extension: String
  file_url: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  updated_at(relative: Boolean, format: String): String
}

# Avatar sizes
enum AvatarVersion {
  LARGE
  MEDIUM
  SMALL
}

# Possible connectables for a new connection
enum BaseConnectableTypeEnum {
  BLOCK
  CHANNEL
}

# Fields common to all Block types
interface Block {
  counts: BlockCounts
}

type BlockCounts {
  channels: Int
  comments: Int
}

# A single channel
type Channel implements Followable, Model {
  blocks(per: Int = 25, page: Int = 1, sort_by: Sorts = POSITION, direction: Directions = ASC, type: ConnectableTypeEnum = null, user_id: ID = null): [Connectable]
  can: ChannelCan
  collaborators: [User] @deprecated(reason: "This only returns Users. Use `members` field instead")
  connections: [Channel] @deprecated(reason: "This field name is going to be repurposed and moved to the root QueryType")
  counts: ChannelCounts
  created_at(relative: Boolean, format: String): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  is_collaboration: Boolean
  is_followed: Boolean
  is_muted: Boolean
  is_open: Boolean @deprecated(reason: "Use `visibility`")
  is_published: Boolean @deprecated(reason: "Use `visibility`")
  members: [Member]
  memberships: [ChannelMembership]
  share: ChannelShare
  share_id: String
  slug: String
  state: String
  title(truncate: Int): String
  type: String
  updated_at(relative: Boolean, format: String): String
  user: User
  visibility: String
}

# The actions that the CurrentUser can perform on the Channel
type ChannelCan {
  add_to: Boolean
  connect: Boolean
  destroy: Boolean
  export: Boolean
  follow: Boolean
  manage: Boolean
  manage_collaborators: Boolean
  mute: Boolean
  read: Boolean
  update: Boolean
}

type ChannelCounts {
  blocks: Int
  channels: Int
  collaborators: Int
  connections: Int
  contents: Int
  followers: Int
}

input ChannelMemberInput {
  id: ID!
  type: MemberTypes = USER
}

# A membership defining the relationship between Channels and Members (Users or Groups)
type ChannelMembership implements Model {
  can: ChannelMembershipCan
  created_at(relative: Boolean, format: String): String
  id: Int
  member: Member
  updated_at(relative: Boolean, format: String): String
}

# The actions that the CurrentUser can perform on the ChannelMembership
type ChannelMembershipCan {
  manage: Boolean
}

# Properties needed to share channels externally
type ChannelShare {
  facebook_url: String
  twitter_url: String
  url: String
}

# Privacy states for a channel
enum ChannelVisibility {
  CLOSED
  PRIVATE
  PUBLIC
}

# Autogenerated input type of ClearNotifications
input ClearNotificationsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  confirm: Boolean!
}

# Autogenerated return type of ClearNotifications
type ClearNotificationsPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# A single comment
type Comment implements Model {
  body(truncate: Int): String
  commentable: Commentable
  created_at(relative: Boolean, format: String): String
  id: Int
  updated_at(relative: Boolean, format: String): String
  user: User
}

# Union of objects that can be commented on
union Commentable = Attachment | Embed | Image | Link | Text

# A block or a channel
type Connectable implements Model {
  can: ConnectableCan
  channels: [Channel]
  comments(direction: Directions = ASC): [Comment]

  # Returns the outer channel if we are inside of one
  connection: Connection
  connections: [Connection]
  created_at(relative: Boolean, format: String): String
  description(format: Format, no_links: Boolean = false): String
  href: String
  id: Int
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible, will need to be killed in favor of a UnionType")
  klass: String
  source: ConnectableSource
  state: String
  title(truncate: Int): String
  to_s(truncate: Int): String
  updated_at(relative: Boolean, format: String): String
  user: User
  visibility: String
}

# The actions that the CurrentUser can perform on the Connectable
type ConnectableCan {
  manage: Boolean
  read: Boolean
}

# Connectable attributes specific to its class
union ConnectableKind = Attachment | Channel | Embed | Image | Link | PendingBlock | Text

type ConnectableSource {
  provider_name: String
  provider_url: String
  title: String
  url: String
}

# Connectable types
enum ConnectableTypeEnum {
  ATTACHMENT
  BLOCK
  CHANNEL
  EMBED
  IMAGE
  LINK
  TEXT
}

# A connection
type Connection implements Model {
  can: ConnectionCan
  channel: Channel
  connectable: Connectable
  created_at(relative: Boolean, format: String): String
  id: Int
  position: Int
  updated_at(relative: Boolean, format: String): String
  user: User
}

# The actions that the CurrentUser can perform on the Connection
type ConnectionCan {
  create: Boolean
  destroy: Boolean
  manage: Boolean
}

# Autogenerated input type of CreateBlock
input CreateBlockInput {
  channel_ids: [ID]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  content: String
  description: String
  original_source_title: String
  original_source_url: String
  source_url: String
  title: String
}

# Autogenerated return type of CreateBlock
type CreateBlockPayload {
  block: Connectable
  channels: [Channel]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateChannel
input CreateChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  title: String!
  visibility: ChannelVisibility = CLOSED
}

# Autogenerated return type of CreateChannel
type CreateChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateComment
input CreateCommentInput {
  block_id: ID!
  body: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated return type of CreateComment
type CreateCommentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  comment: Comment
}

# Autogenerated input type of CreateConnection
input CreateConnectionInput {
  channel_ids: [ID]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
}

# Autogenerated return type of CreateConnection
type CreateConnectionPayload {
  channels: [Channel]

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable: Connectable
  connections: [Connection]
}

# Autogenerated input type of CreateGroup
input CreateGroupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  name: String!
}

# Autogenerated return type of CreateGroup
type CreateGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of CreateUserMessageChannel
input CreateUserMessageChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of CreateUserMessageChannel
type CreateUserMessageChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Your account customer data
type Customer implements Model {
  created_at(relative: Boolean, format: String): String
  current_period_end_at(relative: Boolean, format: String): String
  current_period_start_at(relative: Boolean, format: String): String
  external_id: String
  id: Int
  is_canceled: Boolean
  is_delinquent: Boolean
  is_lifetime: Boolean
  is_premium: Boolean
  plan_id: String
  status: String
  updated_at(relative: Boolean, format: String): String
}

# A single deed
type Deed implements Model {
  action: String
  bulletin_id: ID
  connector: String
  created_at(relative: Boolean, format: String): String
  id: Int
  is_read: Boolean
  item: DeedKind
  item_title(truncate: Int): String
  parent: DeedKind
  target: DeedKind
  updated_at(relative: Boolean, format: String): String
  user: User
}

# A group of deeds
type DeedGroup {
  are_all_read: Boolean
  connector: String
  created_at(relative: Boolean, format: String): String
  deeds: [Deed]
  ids: [ID]
  is_single: Boolean
  items: [DeedKind]
  key: String
  length: Int
  object: DeedKind
  object_phrase(truncate: Int): String
  target: DeedKind
  target_phrase(truncate: Int): String
  user: User
  verb: String
}

# Deed item, target, or parent
union DeedKind = Channel | Comment | Connectable | Null | User

# Autogenerated input type of DeleteChannel
input DeleteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteChannel
type DeleteChannelPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of DeleteConnection
input DeleteConnectionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteConnection
type DeleteConnectionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of DeleteGroup
input DeleteGroupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of DeleteGroup
type DeleteGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Directions to sort blocks
enum Directions {
  ASC
  DESC
}

# An embed block
type Embed implements Block, Model {
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  embed_html: String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  source_url: String
  updated_at(relative: Boolean, format: String): String
}

# Autogenerated input type of ExportChannel
input ExportChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  format: ExportFormats!
  id: ID!
}

# Autogenerated return type of ExportChannel
type ExportChannelPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

enum ExportFormats {
  HTML
  PDF
  ZIP
}

# A feed
type Feed {
  deeds: [Deed]
  groups: [DeedGroup]
  total: Int
}

# Autogenerated input type of Follow
input FollowInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

# Autogenerated return type of Follow
type FollowPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  followable: FollowableType
}

# Fields common to models that can be followed
interface Followable {
  is_followed: Boolean
}

# Followable object
union FollowableType = Channel | User

# Types of followable objects
enum FollowableTypeEnum {
  CHANNEL
  USER
}

# Ways to format a markdown field
enum Format {
  HTML
  MARKDOWN
}

# A Group of Users
type Group implements Model {
  can: GroupCan
  counts: GroupCounts
  created_at(relative: Boolean, format: String): String
  description(format: Format, no_links: Boolean = false): String
  id: Int
  initials: String
  manageable_user_ids: [Int]
  memberships: [GroupMembership]
  name: String
  updated_at(relative: Boolean, format: String): String
  user: User
  users: [User]
}

# The actions that the CurrentUser can perform on the Group
type GroupCan {
  add_to: Boolean
  destroy: Boolean
  manage: Boolean

  # This returns true when the current user can manage at least one membership
  manage_users: Boolean
  update: Boolean
}

type GroupCounts {
  users: Int
}

# A membership defining the relationship between Groups and Users
type GroupMembership implements Model {
  can: GroupMembershipCan
  created_at(relative: Boolean, format: String): String
  id: Int
  updated_at(relative: Boolean, format: String): String
  user: User
}

# The actions that the CurrentUser can perform on the GroupMembership
type GroupMembershipCan {
  manage: Boolean
}

# An image block
type Image implements Block, Model {
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  updated_at(relative: Boolean, format: String): String
}

# Image sizes
enum ImageVersion {
  DISPLAY
  LARGE
  ORIGINAL
  SQUARE
  THUMB
}

# Autogenerated input type of InviteCollaborator
input InviteCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
}

# Autogenerated return type of InviteCollaborator
type InviteCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of InviteGroupUsers
input InviteGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  emails: [String!]!
  id: ID!
}

# Autogenerated return type of InviteGroupUsers
type InviteGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Autogenerated input type of InviteUsers
input InviteUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  emails: [String!]!
}

# Autogenerated return type of InviteUsers
type InviteUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  users: [User]
}

# A link block
type Link implements Block, Model {
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  id: Int
  image_url(size: ImageVersion = DISPLAY): String
  source_url: String
  updated_at(relative: Boolean, format: String): String
}

# Autogenerated input type of Login
input LoginInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
  password: String!
}

# Autogenerated return type of Login
type LoginPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# The current user
type Me implements Model, UserInterface {
  authentication_token: String
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  connection_search(q: String = null, per: Int = 5, direction: Directions = DESC): [Channel]
  contents(per: Int = 1, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: Directions = DESC, seed: Int = 161, q: String = null, type: ConnectableTypeEnum = null): [Connectable]
  counts: MeCounts
  created_at(relative: Boolean, format: String): String
  customer: Customer
  email: String
  feed(type: String = "User", offset: Int = 0, limit: Int = 50, start: String = "+inf", end: String = "-inf"): Feed
  first_name: String
  hidden_email: String
  home_path: String
  href: String
  id: Int
  initials: String
  is_confirmed: Boolean
  is_exceeding_private_connections_limit: Boolean
  is_investor: Boolean
  is_pending_confirmation: Boolean
  is_pending_reconfirmation: Boolean
  is_premium: Boolean
  last_name: String
  name: String
  notifications(offset: Int = 0, limit: Int = 50, start: String = "+inf", end: String = "-inf"): Feed
  plan: String

  # Manifest for uploading new files to S3
  policy: Policy
  post_address: String
  recent_connections(per: Int = 1): [Channel]
  settings: MeSettings
  slug: String
  unconfirmed_email: String
  updated_at(relative: Boolean, format: String): String
}

type MeCounts {
  followers: Int
  following: Int
  notifications: Int
  private_connections: Int
  private_connections_limit: Int
}

type MeSettings {
  exclude_from_indexes: Boolean
  receive_email: String
  receive_newsletter: Boolean
  show_tour: Boolean
}

# Union of Channel members
union Member = Group | User

# Member types
enum MemberTypes {
  GROUP
  USER
}

# Fields common to all models
interface Model {
  created_at(relative: Boolean, format: String): String
  id: Int
  updated_at(relative: Boolean, format: String): String
}

type Mutation {
  add_channel_members(input: AddChannelMembersInput!): AddChannelMembersPayload
  add_collaborators(input: AddCollaboratorInput!): AddCollaboratorPayload @deprecated(reason: "Use `add_channel_member` instead")
  add_group_users(input: AddGroupUsersInput!): AddGroupUsersPayload
  clear_notifications(input: ClearNotificationsInput!): ClearNotificationsPayload
  create_block(input: CreateBlockInput!): CreateBlockPayload
  create_channel(input: CreateChannelInput!): CreateChannelPayload
  create_comment(input: CreateCommentInput!): CreateCommentPayload
  create_connection(input: CreateConnectionInput!): CreateConnectionPayload
  create_group(input: CreateGroupInput!): CreateGroupPayload
  create_user_message_channel(input: CreateUserMessageChannelInput!): CreateUserMessageChannelPayload
  delete_channel(input: DeleteChannelInput!): DeleteChannelPayload
  delete_connection(input: DeleteConnectionInput!): DeleteConnectionPayload
  delete_group(input: DeleteGroupInput!): DeleteGroupPayload
  export_channel(input: ExportChannelInput!): ExportChannelPayload
  follow(input: FollowInput!): FollowPayload
  invite_collaborator(input: InviteCollaboratorInput!): InviteCollaboratorPayload @deprecated(reason: "Use `invite_channel_member` instead")
  invite_group_users(input: InviteGroupUsersInput!): InviteGroupUsersPayload
  invite_users(input: InviteUsersInput!): InviteUsersPayload
  login(input: LoginInput!): LoginPayload
  mute_channel(input: MuteChannelInput!): MuteChannelPayload
  read_notification(input: ReadNotificationInput!): ReadNotificationPayload
  registration(input: RegistrationInput!): RegistrationPayload
  remove_channel_members(input: RemoveChannelMembersInput!): RemoveChannelMembersPayload
  remove_collaborators(input: RemoveCollaboratorInput!): RemoveCollaboratorPayload @deprecated(reason: "Use `remove_channel_member` instead")
  remove_connection(input: RemoveConnectionInput!): RemoveConnectionPayload
  remove_group_users(input: RemoveGroupUsersInput!): RemoveGroupUsersPayload
  share_channel(input: ShareChannelInput!): ShareChannelPayload
  unfollow(input: UnfollowInput!): UnfollowPayload
  unmute_channel(input: UnmuteChannelInput!): UnmuteChannelPayload
  update_account(input: UpdateAccountInput!): UpdateAccountPayload
  update_block(input: UpdateBlockInput!): UpdateBlockPayload
  update_channel(input: UpdateChannelInput!): UpdateChannelPayload
  update_group(input: UpdateGroupInput!): UpdateGroupPayload
}

# Autogenerated input type of MuteChannel
input MuteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of MuteChannel
type MuteChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# An object with an ID.
interface Node {
  # ID of the object.
  id: ID!
}

# An empty object
type Null {
  is_null: Boolean
}

# Object types for scoped search results
enum ObjectType {
  CHANNEL
  USER
}

# A block which has not yet found its calling
type PendingBlock implements Block, Model {
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  id: Int
  updated_at(relative: Boolean, format: String): String
}

# A policy
type Policy {
  AWSAccessKeyId: String
  acl: String
  bucket: String
  expires: String
  key: String
  policy: String
  signature: String
  success_action_status: String
}

# The query root for this schema
type Query {
  block(id: ID!): Connectable

  # A single channel
  channel(id: ID!): Channel
  explore(per: Int = 1, page: Int = 1, type: SearchType, direction: Directions = DESC, sort_by: SearchSorts = null): [SearchResult]

  # Interface for getting the follow status of users or channels
  followable(id: ID, type: FollowableTypeEnum): FollowableType
  group(id: ID!): Group

  # The current logged in user
  me: Me

  # Fetches an object given its ID.
  node(
    # ID of the object.
    id: ID!
  ): Node
  search(per: Int = 1, page: Int = 1, sort_by: SearchSorts = null, direction: Directions = DESC, seed: Int = 161, q: String! = null, type: SearchType = null, object_id: String = null, object_type: ObjectType = null): [SearchResult]
  searches: Searches

  # Is this endpoint operational?
  status: String

  # A single user
  user(id: ID!): User
}

# Autogenerated input type of ReadNotification
input ReadNotificationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  notification_id: ID!
}

# Autogenerated return type of ReadNotification
type ReadNotificationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deed: Deed
}

# Autogenerated input type of Registration
input RegistrationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String!
  first_name: String!
  last_name: String!
  password: String!
  password_confirmation: String!
}

# Autogenerated return type of Registration
type RegistrationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of RemoveChannelMembers
input RemoveChannelMembersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput]!
}

# Autogenerated return type of RemoveChannelMembers
type RemoveChannelMembersPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RemoveCollaborator
input RemoveCollaboratorInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  user_ids: [ID]!
}

# Autogenerated return type of RemoveCollaborator
type RemoveCollaboratorPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RemoveConnection
input RemoveConnectionInput {
  channel_id: ID!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
}

# Autogenerated return type of RemoveConnection
type RemoveConnectionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  status: String
}

# Autogenerated input type of RemoveGroupUsers
input RemoveGroupUsersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

# Autogenerated return type of RemoveGroupUsers
type RemoveGroupUsersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# Possible types for search results
union SearchResult = Channel | Connectable | Null | User

# Ways to sort blocks
enum SearchSorts {
  ALPHA
  CREATED_AT
  FOLLOWER_COUNT
  LENGTH
  RANDOM
  UPDATED_AT
}

# Ways to filter search by type
enum SearchType {
  CHANNEL
  CONNECTABLE
  USER
}

type Searches {
  collaborators(query: String!, types: [SearchesCollaboratorsType] = [USER, GROUP], limit: Int = 10): [Member]
}

enum SearchesCollaboratorsType {
  GROUP
  USER
}

# Autogenerated input type of ShareChannel
input ShareChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  enable: Boolean!
  id: ID!
}

# Autogenerated return type of ShareChannel
type ShareChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Ways to sort blocks
enum Sorts {
  CREATED_AT
  POSITION
  UPDATED_AT
}

# A text block
type Text implements Block, Model {
  content(format: Format, no_links: Boolean = false): String
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String
  id: Int
  updated_at(relative: Boolean, format: String): String
}

# Autogenerated input type of Unfollow
input UnfollowInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

# Autogenerated return type of Unfollow
type UnfollowPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  followable: FollowableType
}

# Autogenerated input type of UnmuteChannel
input UnmuteChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  id: ID!
}

# Autogenerated return type of UnmuteChannel
type UnmuteChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateAccount
input UpdateAccountInput {
  bio: String

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  email: String
  exclude_from_indexes: Boolean
  first_name: String
  home_path: String
  last_name: String
  receive_email: String
  receive_newsletter: Boolean
  show_tour: Boolean
}

# Autogenerated return type of UpdateAccount
type UpdateAccountPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  me: Me
}

# Autogenerated input type of UpdateBlock
input UpdateBlockInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  content: String
  description: String
  id: ID!
  title: String
}

# Autogenerated return type of UpdateBlock
type UpdateBlockPayload {
  block: Connectable

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateChannel
input UpdateChannelInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  id: ID!
  title: String
  visibility: ChannelVisibility
}

# Autogenerated return type of UpdateChannel
type UpdateChannelPayload {
  channel: Channel

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateGroup
input UpdateGroupInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  description: String
  id: ID!
  name: String
}

# Autogenerated return type of UpdateGroup
type UpdateGroupPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: Group
}

# A single user
type User implements Followable, Model, UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  contents(per: Int = 1, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: Directions = DESC, seed: Int = 161, q: String = null, type: ConnectableTypeEnum = null): [Connectable]
  counts: UserCounts
  created_at(relative: Boolean, format: String): String
  first_name: String
  hidden_email: String
  href: String
  id: Int
  initials: String
  is_followed: Boolean
  is_investor: Boolean
  is_premium: Boolean
  last_name: String
  name: String
  slug: String
  updated_at(relative: Boolean, format: String): String
}

# The actions that the CurrentUser can perform on the User
type UserCan {
  follow: Boolean
  manage: Boolean
}

type UserCounts {
  blocks: Int
  channels: Int
  followers: Int
  following: Int
}

# Fields common to all users
interface UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  contents(per: Int = 1, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: Directions = DESC, seed: Int = 161, q: String = null, type: ConnectableTypeEnum = null): [Connectable]
  first_name: String
  hidden_email: String
  href: String
  initials: String
  is_investor: Boolean
  is_premium: Boolean
  last_name: String
  name: String
  slug: String
}