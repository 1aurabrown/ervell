{
  "name": "jadeify",
  "description": "A browserify transform for turning .jade files into template functions",
  "keywords": [
    "browserify",
    "jade",
    "templates",
    "templating",
    "transform"
  ],
  "version": "4.4.0",
  "author": {
    "name": "Domenic Denicola",
    "email": "d@domenic.me",
    "url": "https://domenic.me/"
  },
  "license": "WTFPL",
  "repository": {
    "type": "git",
    "url": "https://github.com/domenic/jadeify"
  },
  "main": "lib/jadeify.js",
  "files": [
    "lib/"
  ],
  "scripts": {
    "test": "mocha",
    "lint": "jshint lib"
  },
  "dependencies": {
    "through": "^2.3.6"
  },
  "peerDependencies": {
    "browserify": ">= 2.4.0 < 12",
    "jade": "^1.9.2"
  },
  "devDependencies": {
    "browserify": "^11.0.0",
    "concat-stream": "^1.5.0",
    "jade": "^1.11.0",
    "jsdom": "^5.6.1",
    "jshint": "^2.8.0",
    "mocha": "^2.2.5"
  },
  "readme": "# A Browserify Transform for Jade\n\n**Jadeify** lets you use [Jade][] templates with [browserify][] in the simplest way possible:\n\n```js\nvar template = require(\"./template.jade\");\n\ndocument.getElementById(\"my-thing\").innerHTML = template({\n    localVar: \"value\",\n    anotherOne: \"another value\"\n});\n```\n\n## Setup\n\nWhen creating your browserify bundle, just add this line:\n\n```js\nbundle.transform(require(\"jadeify\"));\n```\n\nor if you are a command line cowboy, something along the lines of\n\n```js\nbrowserify -t jadeify entry.js -o bundle.js\n```\n\nNote that this project peer-depends on Jade and each template will do `require(\"jade/runtime\")`, so everything will just work: there's no need to add any Jade-related stuff to your bundle manually. (See below if your need to customize this.)\n\nSo yeah, now `require`ing any `.jade` files will give you back a template function. Have fun!\n\n## Configuration\n\nAs with most browserify transforms, you can configure jadeify via the second argument to `bundle.transform`:\n\n```js\nbundle.transform(require(\"jadeify\"), { compileDebug: true, pretty: true });\n```\n\nor inside your `package.json` configuration:\n\n```json\n{\n    \"name\": \"my-spiffy-package\",\n    \"browserify\": {\n        \"transform\": [\n            [\"jadeify\", { \"compileDebug\": true, \"pretty\": true }]\n        ]\n    }\n}\n```\n\nMost options given to jadeify will be passed through to [Jade's API][].\n\n### `runtimePath` option\n\nThere is one additional option, `runtimePath`, which can be used to customize the `require` statement inserted at the top of every resulting template. If supplied, instead of `require(\"jade/runtime\")`, the given module ID will be required.\n\nThis can be useful if you are using jadeify as a dependency in a standalone library. For example, if your package `demo-package` depends on both `jade` and `jadeify`, you can do\n\n```js\nbundle.transform(require(\"jadeify\"), { runtimePath: require.resolve(\"jade/runtime\") });\n```\n\ninside your package. If your package is then located at `node_modules/demo-package`, and thus its `jade` dependency is located at `node_modules/demo-package/node_modules/jade`, this will ensure that the template files output by your library contain the equivalent of `require(\"demo-package/node_modules/jade/runtime\")`, instead of the default `require(\"jade/runtime\")`. This way your library completely encapsulates the presence of Jade, and doesn't require its installation at top level.\n\n[Jade]: http://jade-lang.com/\n[browserify]: https://github.com/substack/node-browserify\n[Jade's API]: http://jade-lang.com/api/\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/domenic/jadeify/issues"
  },
  "homepage": "https://github.com/domenic/jadeify",
  "_id": "jadeify@4.4.0",
  "_shasum": "a281bc2fdce20955727deb352def3cc5e021de41",
  "_from": "jadeify@*",
  "_resolved": "https://registry.npmjs.org/jadeify/-/jadeify-4.4.0.tgz"
}
